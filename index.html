<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galaxia de San Valent√≠nüíóüåå</title>


    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Indie+Flower&display=swap" rel="stylesheet">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>‚ù§Ô∏è</text></svg>">
    <link rel="preload" as="image" href="https://dl.dropboxusercontent.com/scl/fi/gfbim428ac1q71zyamlnk/log.webp?rlkey=00mkji2yiuq9xif3usmdrj7ut&st=kl29vn0j&raw=1">
    <link rel="preload" as="image" href="https://dl.dropboxusercontent.com/scl/fi/delyd48mr1sylzs3qdqkt/card1.jpg?rlkey=156js3vvd17da355pxfyliib6&st=ol4fspc1&raw=1">
    <link rel="preload" as="image" href="https://dl.dropboxusercontent.com/scl/fi/nn4tplgv8mtlh2ehcdfwg/card2.jpg?rlkey=74ybr7iiv4qecydpd9qmn2mzn&st=6lh62k1r&raw=1">
    <link rel="preload" as="image" href="https://dl.dropboxusercontent.com/scl/fi/2ohu5mqrbwjnp9aqz9n7y/card3.jpg?rlkey=9k2au868ej93muc87bayvfrz5&st=06nbpd04&raw=1">

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100%; height: 100%;
            margin: 0; overflow: hidden;
            background-color: #000000;
            font-family: 'Indie Flower', cursive;
            cursor: grab;
            -webkit-user-select: none; user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        body:active { cursor: grabbing; }
        canvas { display: block; position: fixed; top: 0; left: 0; z-index: 1; }

        #main-title {
            position: absolute;
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 4 rem;
            color: #FFB6C1;
            text-shadow: 0 0 15px #FF69B4, 0 0 25px #DC143C;
            z-index: 10;
            pointer-events: none;
            text-align: center;
            white-space: nowrap;
        }

        #start-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: black; display: flex; justify-content: center; align-items: center;
            flex-direction: column; color: white; z-index: 9999; padding: 20px;
        }
        
        #start-button-image {
            width: 280px;
            height: auto;
            cursor: pointer;
            filter: drop-shadow(0 0 15px #FF1493) drop-shadow(0 0 25px #FF0000);
            transition: all 0.3s ease;
            margin-bottom: 20px;
            animation: latido 1.5s infinite ease-in-out;
        }

        #start-button-image:hover {
            filter: drop-shadow(0 0 20px #FF69B4) drop-shadow(0 0 35px #FF1493);
            transform: scale(1.05);
        }
        
        @keyframes latido {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.08); }
        }

        #start-text {
            font-size: 1.8em;
            color: #FFB6C1;
            text-shadow: 0 0 10px #FF1493;
            text-align: center;
        }

        #love-card-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(5px);
            cursor: pointer;
        }

        #love-card {
            position: relative;
            width: 90%; max-width: 400px;
            aspect-ratio: 9 / 16;
            background-size: cover;
            background-position: center;
            border-radius: 20px;
            box-shadow: 0 0 30px #DC143C, 0 0 50px #FF1493;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 25px;
            text-align: center;
            overflow: hidden;
        }

        #love-card::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.4);
            z-index: 1;
        }

        #love-card-text {
            position: relative;
            font-size: 3em;
            color: #ffffff;
            text-shadow: 0 0 8px black, 0 0 15px black;
            z-index: 2;
        }

        @media (max-width: 768px) {
            #main-title { font-size: 3.4em; top: 25px; }
            #love-card-text { font-size: 2.8em; }
        }

        @media (max-width: 480px) {
            #main-title { font-size: 2.5em; top: 20px; }
        }
    </style>

</head>

<body>
    <h1 id="main-title">Feliz San Valent√≠n Amorcito ‚ù§Ô∏è</h1>

    <div id="start-screen">
    <!-- <img id="start-button-image" src="https://i.pinimg.com/originals/c0/f5/ae/c0f5ae81c90af4a43b91806b82fd3505.gif" alt="Iniciar">  -->
    <img id="start-button-image" src="https://i.pinimg.com/736x/1f/d9/6f/1fd96fa73d7019a044bea25c8969a99e.jpg" alt="Iniciar"> 
    <div id="start-text">Ingresa Amorcito ‚ù§Ô∏è‚Äçüî•</div>
    </div>

    <div id="love-card-overlay">
        <div id="love-card">
            <p id="love-card-text"></p>
        </div>
    </div>

    <audio id="background-music" loop>
        <!-- <source src="https://dl.dropboxusercontent.com/scl/fi/kgo1eaoh44tpfbcq3ta4r/sound.mp3?rlkey=13dpol310dodn9r45rolm2nzp&st=30esvuy7&raw=1" type="audio/mpeg"> -->
        <source src="https://audio.com/sophia-lauren/audio/interstellar-main-theme-hans-zimmer-epic-instrumentalpiano-cover" type="audio/mpeg">
    </audio>

    <canvas id="galaxy-canvas"></canvas>

    <script type="importmap">
    { "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        } }
    </script>
    
    <script>
        document.addEventListener('contextmenu', event => event.preventDefault());
        document.onkeydown = function(e) {
            if (e.keyCode == 123 || (e.ctrlKey && e.shiftKey && (e.keyCode == 'I'.charCodeAt(0) || e.keyCode == 'J'.charCodeAt(0) || e.keyCode == 'C'.charCodeAt(0))) || (e.ctrlKey && (e.keyCode == 'U'.charCodeAt(0) || e.keyCode == 'S'.charCodeAt(0)))) {
                return false;
            }
        };
    </script>
    
    <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

    // ===================================================================
    // =============== M√ìDULO DE AJUSTES EDITABLE ========================
    // ===================================================================

    const CONFIG = {
        galaxy: { rotationSpeed: 0.12, centerExclusionRadius: 45 },
        elementExclusionRadius: 40,
        blackHole: { radius: 12, segments: 64, color1: '#000000', color2: '#050505' },
        
        accretionRing: {
            innerRadius: 18, outerRadius: 32, segments: 128,
            centerColor: '#FF69B4',
            midColor: '#FF1493',
            edgeColor: '#8B0000',
            emissiveIntensity: 1.9,
        },

        particles: {
            // === NUBE PRINCIPAL OVOIDE (plano ecuatorial, densa) ===
            coreStars: {
                count: 2000,        // m√°s part√≠culas totales
                radius: 120,
                maxHeight: 60,
                size: 0.20
            },

            // === CAPA SUPERIOR E INFERIOR ‚Äî forma esf√©rica achatada ===
            // Agrega part√≠culas fuera del plano para romper la planitud
            sphericalHalo: {
                count: 18000,        // part√≠culas del halo 3D
                radiusXZ: 110,       // radio en el plano horizontal
                radiusY: 55,         // radio vertical (achatado: < radiusXZ)
                size: 0.18,
                minDistFromCenter: 28
            },

            backgroundStars: { count: 5000, radius: 500, size: 0.2 },
            
            // === TEXTOS SAN VALENT√çN ===
            texts: {
                count: 40, width: 45, height: 20,
                minRadius: null, maxRadius: 120,
                content: [
                    "Feliz San Valent√≠n", "Te amo amorcito", "Eres mi coraz√≥n",
                    "Mi amor eterno", "Mi cora es tuyo", "Contigo lo es todo",
                    "Eres mi valent√≠n", "Un beso para ti", "Te quiero infinito",
                    "Amorcitooooooo", "Mi media naranja", "T√∫ eres mi hogar",
                    "Para m√°s citas", "Coraz√≥n m√≠o", "Eres lo que so√±√©",
                    "Te Amo", "Un abrazote para ti", "Cada d√≠a te quiero m√°s",
                    "Eres mi mundo", "Solo t√∫ y yo"
                ],
                colors: [
                    { fill: '#FF69B4', shadow: '#FF1493' },
                    { fill: '#FFB6C1', shadow: '#DC143C' },
                    { fill: '#FFC0CB', shadow: '#FF69B4' }
                ]
            },
            images: {
                count: 26, size: 12,
                minRadius: null, maxRadius: 120,
                urls: [ 
                    'https://dl.dropboxusercontent.com/scl/fi/07lqextmf3ae6g7ihipsl/img1.gif?rlkey=ncnihs3zzqlwyjnwdxbs9je04&st=9dazhxpg&raw=1', 
                    'https://dl.dropboxusercontent.com/scl/fi/ibnyxqdqafhv705wgctzm/img2.png?rlkey=t8sholdyg9ca4c61tyi5wnpjn&st=8kibpf9a&raw=1', 
                    'https://dl.dropboxusercontent.com/scl/fi/06rmjf457tjqlzrvxrd8z/img3.png?rlkey=my0hs6l0yqm9876txolf4geo4&st=07imfsey&raw=1', 
                    'https://dl.dropboxusercontent.com/scl/fi/ugr4ftcvi7t9675d8c4kr/img4.png?rlkey=snur82qbg4qx49taucf96oo97&st=i2qztukc&raw=1', 
                    'https://dl.dropboxusercontent.com/scl/fi/gw7gtnpcs3prw47ojw5mx/img5.png?rlkey=kzn9psxo3ipd8v2v5r15qe36x&st=un71twed&raw=1'
                ]               
            }
        },

        loveCards: {
                // URLs actualizadas a dl.dropboxusercontent.com
                images: [ 
                    'https://dl.dropboxusercontent.com/scl/fi/delyd48mr1sylzs3qdqkt/card1.jpg?rlkey=156js3vvd17da355pxfyliib6&st=ol4fspc1&raw=1', 
                    'https://dl.dropboxusercontent.com/scl/fi/nn4tplgv8mtlh2ehcdfwg/card2.jpg?rlkey=74ybr7iiv4qecydpd9qmn2mzn&st=6lh62k1r&raw=1', 
                    'https://dl.dropboxusercontent.com/scl/fi/2ohu5mqrbwjnp9aqz9n7y/card3.jpg?rlkey=9k2au868ej93muc87bayvfrz5&st=06nbpd04&raw=1',
                    'https://i.pinimg.com/736x/96/f5/cc/96f5cc51a9c6b62824bc3fa87ac2508c.jpg',
                    'https://i.pinimg.com/736x/67/7b/fb/677bfb7752742ceff72b86f6df9684b0.jpg' 
                ],
                phrases: [
                    "Eres la raz√≥n de mi sonrisa cada d√≠a. ‚ù§Ô∏è",
                    "En nuestro mundo de bloques, t√∫ eres el spawn ideal. Sigamos construyendo juntos.",
                    "Mi galaxia entera gira alrededor de ti.",
                    "Eres el sue√±o m√°s bonito que se volvi√≥ realidad.",
                    "Tu beso enciende mi alma y tu mirada me conquista cada vez. Este San Valent√≠n, prom√©teme que seremos fuego eterno.",
                    "Eres como mi caf√© ma√±anero: adictivo, caliente y esencial para mi felicidad.",
                    "No necesito Boombox caros, tu voz en VC es mi sonido favorito."
                ]
            },

        shootingStars: {
            enabled: true,
            spawnProbability: 0.01,
            speed: 1.2
        },
        lighting: {
            ambientLight: { color: '#ffffff', intensity: 0.1 },
            pointLight: { color: '#FF69B4', intensity: 2.5, distance: 350 }
        },
        bloomEffect: { threshold: 0.68, strength: 1.5, radius: 0.5 },
        cameraControls: { minDistance: 30, maxDistance: 250 }
    };
    // ===================================================================

    let scene, camera, renderer, controls, galaxyGroup, clock, sphereMaterial, composer;
    let loveTexts = [], loveImages = [], shootingStars = [];
    let occupiedPositions = [];
    let raycaster, mouse;
    let currentCardIndex = 0;

    function init() {
        scene = new THREE.Scene();
        clock = new THREE.Clock();
        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('galaxy-canvas'), antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; controls.dampingFactor = 0.05;
        controls.minDistance = CONFIG.cameraControls.minDistance;
        controls.maxDistance = CONFIG.cameraControls.maxDistance;

        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = CONFIG.bloomEffect.threshold;
        bloomPass.strength = CONFIG.bloomEffect.strength;
        bloomPass.radius = CONFIG.bloomEffect.radius;
        composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        const { ambientLight, pointLight } = CONFIG.lighting;
        scene.add(new THREE.AmbientLight(ambientLight.color, ambientLight.intensity));
        const mainLight = new THREE.PointLight(pointLight.color, pointLight.intensity, pointLight.distance);
        mainLight.position.set(0, 0, 0);
        scene.add(mainLight);
        
        galaxyGroup = new THREE.Group();
        scene.add(galaxyGroup);

        createBlackHole();
        createCoreStars();
        createSphericalHalo();     // ‚Üê NUEVO: capa 3D ovoide
        createBackgroundStars();
        createLoveElements();

        window.addEventListener('resize', onWindowResize);
        renderer.domElement.addEventListener('click', onCanvasClick);
        onWindowResize();
        animate();
    }
    
    function createBlackHole() {
        const bhConfig = CONFIG.blackHole;
        const ringConfig = CONFIG.accretionRing;
        sphereMaterial = new THREE.ShaderMaterial({
            uniforms: { uTime: { value: 0.0 }, uColor1: { value: new THREE.Color(bhConfig.color1) }, uColor2: { value: new THREE.Color(bhConfig.color2) } },
            vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
            fragmentShader: `uniform float uTime; uniform vec3 uColor1; uniform vec3 uColor2; varying vec2 vUv; float noise(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123); } void main() { float n = noise(vUv * 4.0 + uTime * 0.1); vec3 mixedColor = mix(uColor1, uColor2, n); gl_FragColor = vec4(mixedColor, 1.0); }`
        });
        scene.add(new THREE.Mesh(new THREE.SphereGeometry(bhConfig.radius, bhConfig.segments, bhConfig.segments), sphereMaterial));
        const ringGeometry = new THREE.RingGeometry(ringConfig.innerRadius, ringConfig.outerRadius, ringConfig.segments);
        const ringMaterial = new THREE.ShaderMaterial({
            uniforms: { innerRadius: { value: ringConfig.innerRadius }, outerRadius: { value: ringConfig.outerRadius }, centerColor: { value: new THREE.Color(ringConfig.centerColor) }, midColor: { value: new THREE.Color(ringConfig.midColor) }, edgeColor: { value: new THREE.Color(ringConfig.edgeColor) }, emissiveIntensity: { value: ringConfig.emissiveIntensity } },
            vertexShader: `varying vec3 vPosition; void main() { vPosition = position; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
            fragmentShader: `uniform float innerRadius; uniform float outerRadius; uniform vec3 centerColor; uniform vec3 midColor; uniform vec3 edgeColor; uniform float emissiveIntensity; varying vec3 vPosition; void main() { float distance = length(vPosition.xy); float normalizedDistance = clamp((distance - innerRadius) / (outerRadius - innerRadius), 0.0, 1.0); vec3 finalColor; if (normalizedDistance < 0.5) { finalColor = mix(centerColor, midColor, normalizedDistance * 2.0); } else { finalColor = mix(midColor, edgeColor, (normalizedDistance - 0.5) * 2.0); } float glowFactor = 1.0 - smoothstep(0.0, 1.0, normalizedDistance); vec3 emissiveColor = finalColor * emissiveIntensity * glowFactor; gl_FragColor = vec4(finalColor + emissiveColor, 1.0); }`,
            side: THREE.DoubleSide
        });
        const goldenRing = new THREE.Mesh(ringGeometry, ringMaterial);
        goldenRing.rotation.x = Math.PI / 2;
        scene.add(goldenRing);
    }

    // ====== CAPA ECUATORIAL ORIGINAL (mantenida intacta) ======
    function createCoreStars() {
        const coreConfig = CONFIG.particles.coreStars;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(coreConfig.count * 3);
        const colors = new Float32Array(coreConfig.count * 3);
        const color = new THREE.Color();
        for (let i = 0; i < coreConfig.count; i++) {
            const distance = CONFIG.accretionRing.outerRadius + Math.random() * (coreConfig.radius - CONFIG.accretionRing.outerRadius);
            const angle = Math.random() * Math.PI * 2;
            const y = (Math.random() - 0.5) * coreConfig.maxHeight * Math.pow(1 - (distance / coreConfig.radius), 1.5);
            positions.set([Math.cos(angle) * distance, y, Math.sin(angle) * distance], i * 3);
            
            const hue = 0.9 + Math.random() * 0.15;
            const saturation = 0.8 + Math.random() * 0.2;
            const lightness = 0.6 + Math.random() * 0.4;
            color.setHSL(hue % 1, saturation, lightness);
            colors.set([color.r, color.g, color.b], i * 3);
        }
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        const material = new THREE.PointsMaterial({ size: coreConfig.size, blending: THREE.AdditiveBlending, vertexColors: true, transparent: true });
        galaxyGroup.add(new THREE.Points(geometry, material));
    }

    // ====== NUEVA CAPA: HALO ESFEROIDAL ACHATADO ======
    // Distribuye part√≠culas en un elipsoide (achatado verticalmente)
    // que cubre uniformemente el volumen superior e inferior de la galaxia,
    // haciendo que la nube se vea redondeada/ovoide y no plana.
    function createSphericalHalo() {
        const haloConfig = CONFIG.particles.sphericalHalo;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(haloConfig.count * 3);
        const colors = new Float32Array(haloConfig.count * 3);
        const color = new THREE.Color();

        let filled = 0;
        while (filled < haloConfig.count) {
            // Muestra aleatoria uniforme dentro de un elipsoide usando rechazo
            const rx = (Math.random() * 2 - 1);
            const ry = (Math.random() * 2 - 1);
            const rz = (Math.random() * 2 - 1);

            // Coordenadas en espacio elipsoidal normalizado
            // Si rx¬≤+ry¬≤+rz¬≤ > 1, el punto cae fuera del elipsoide ‚Üí rechazar
            if (rx * rx + ry * ry + rz * rz > 1.0) continue;

            const x = rx * haloConfig.radiusXZ;
            const y = ry * haloConfig.radiusY;
            const z = rz * haloConfig.radiusXZ;

            // Excluir la zona central (esfera de exclusi√≥n)
            const distFromCenter = Math.sqrt(x * x + y * y + z * z);
            if (distFromCenter < haloConfig.minDistFromCenter) continue;

            // Densidad decreciente hacia los bordes: bias hacia el interior
            // usando una distribuci√≥n radial c√∫bica (m√°s denso en el centro)
            // Aceptar con probabilidad proporcional a (1 - r_norm)^1.5
            const rNorm = distFromCenter / Math.max(haloConfig.radiusXZ, haloConfig.radiusY);
            if (Math.random() > Math.pow(1.0 - rNorm * 0.7, 1.2)) continue;

            positions.set([x, y, z], filled * 3);

            // Colores: misma paleta rosa/roja que el n√∫cleo
            const hue = 0.88 + Math.random() * 0.18;
            const saturation = 0.6 + Math.random() * 0.4;
            const lightness = 0.45 + Math.random() * 0.45;
            color.setHSL(hue % 1, saturation, lightness);
            colors.set([color.r, color.g, color.b], filled * 3);

            filled++;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // Part√≠culas del halo ligeramente m√°s peque√±as y menos opacas
        // para dar sensaci√≥n de profundidad sin tapar el disco central
        const material = new THREE.PointsMaterial({
            size: haloConfig.size,
            blending: THREE.AdditiveBlending,
            vertexColors: true,
            transparent: true,
            opacity: 0.65
        });

        galaxyGroup.add(new THREE.Points(geometry, material));
    }

    // ================== ELEMENTOS DE AMOR ==================
    function createLoveElements() {
        const textConfig = CONFIG.particles.texts;
        const imageConfig = CONFIG.particles.images;
        const textureLoader = new THREE.TextureLoader();

        for (let i = 0; i < textConfig.count; i++) {
            const colorData = textConfig.colors[i % textConfig.colors.length];
            const texture = createTextTexture(textConfig.content[i % textConfig.content.length], colorData);
            const material = new THREE.MeshPhongMaterial({ map: texture, transparent: true, alphaTest: 0.1, emissive: colorData.fill, emissiveIntensity: 1.2 });
            const textMesh = new THREE.Mesh(new THREE.PlaneGeometry(textConfig.width, textConfig.height), material);
            setElementOrbitPosition(textMesh, textConfig.minRadius, textConfig.maxRadius);
            galaxyGroup.add(textMesh); loveTexts.push(textMesh);
        }

        for (let i = 0; i < imageConfig.count; i++) {
            const imageUrl = imageConfig.urls[i % imageConfig.urls.length];
            textureLoader.load(imageUrl, (texture) => {
                const aspect = texture.image.width / texture.image.height;
                const w = aspect > 1 ? imageConfig.size : imageConfig.size * aspect;
                const h = aspect > 1 ? imageConfig.size / aspect : imageConfig.size;
                
                const roundedTexture = createRoundedImageTexture(texture);
                const material = new THREE.MeshBasicMaterial({
                    map: roundedTexture,
                    transparent: true,
                    alphaTest: 0.1,
                    color: 0xBBBBBB
                });

                const imageMesh = new THREE.Mesh(new THREE.PlaneGeometry(w, h), material);
                setElementOrbitPosition(imageMesh, imageConfig.minRadius, imageConfig.maxRadius);
                galaxyGroup.add(imageMesh); loveImages.push(imageMesh);
            });
        }
    }

    function createBackgroundStars() {
        const bgConfig = CONFIG.particles.backgroundStars;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(bgConfig.count * 3);
        for (let i = 0; i < bgConfig.count; i++) {
            const r = bgConfig.radius;
            positions.set([(Math.random() - 0.5) * 2 * r, (Math.random() - 0.5) * 2 * r, (Math.random() - 0.5) * 2 * r], i * 3);
        }
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const material = new THREE.PointsMaterial({ size: bgConfig.size, color: 0xffffff, transparent: true, opacity: 0.5 });
        scene.add(new THREE.Points(geometry, material));
    }
    
    function createShootingStar() {
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array([0,0,0]), 3));
        const material = new THREE.PointsMaterial({ color: 0xffffff, size: 1.8, blending: THREE.AdditiveBlending, transparent: true });
        const star = new THREE.Points(geometry, material);

        const [x, y, z] = [ THREE.MathUtils.randFloatSpread(800), THREE.MathUtils.randFloat(100, 300), THREE.MathUtils.randFloatSpread(800) ];
        star.position.set(x, y, z);
        
        star.userData.velocity = new THREE.Vector3(
            (Math.random() < 0.5 ? -1 : 1) * CONFIG.shootingStars.speed,
            -CONFIG.shootingStars.speed * 0.5,
            (Math.random() - 0.5) * 2
        );
        star.userData.life = 0;

        shootingStars.push(star);
        scene.add(star);
    }

    function setElementOrbitPosition(element, minRadius, maxRadius) {
        const safeMinRadius = minRadius || CONFIG.elementExclusionRadius;
        const safeMaxRadius = maxRadius || CONFIG.particles.coreStars.radius;
        const minSeparation = 18; const maxAttempts = 50;
        let validPosition = false; let attempts = 0;
        let finalPosition = { x: 0, y: 0, z: 0 };
        while (!validPosition && attempts < maxAttempts) {
            attempts++;
            const radius = safeMinRadius + Math.random() * (safeMaxRadius - safeMinRadius);
            const theta = Math.random() * Math.PI * 2;
            const maxVerticalOffset = 15;
            const y = (Math.random() - 0.5) * maxVerticalOffset;
            const x = radius * Math.cos(theta); const z = radius * Math.sin(theta);
            validPosition = true;
            for (let pos of occupiedPositions) {
                const distance = Math.sqrt(Math.pow(x - pos.x, 2) + Math.pow(y - pos.y, 2) + Math.pow(z - pos.z, 2));
                if (distance < minSeparation) { validPosition = false; break; }
            }
            if (validPosition) finalPosition = { x, y, z };
        }
        element.position.set(finalPosition.x, finalPosition.y, finalPosition.z);
        occupiedPositions.push(finalPosition);
    }
    
    function createTextTexture(text, color) {
        const canvas = document.createElement('canvas'); canvas.width = 1536; canvas.height = 512;
        const context = canvas.getContext('2d');
        context.font = '84px "Indie Flower", cursive'; context.fillStyle = color.fill;
        context.textAlign = 'center'; context.textBaseline = 'middle';
        context.shadowColor = color.shadow; context.shadowBlur = 10;
        const words = text.split(' '); let lines = []; let currentLine = words[0];
        const maxWidth = canvas.width - 100, lineHeight = 100;
        for (let i = 1; i < words.length; i++) {
            const testLine = currentLine + ' ' + words[i];
            if (context.measureText(testLine).width > maxWidth && currentLine.length > 0) { lines.push(currentLine); currentLine = words[i]; }
            else { currentLine = testLine; }
        }
        lines.push(currentLine);
        const startY = canvas.height / 2 - (lines.length - 1) * lineHeight / 2;
        lines.forEach((line, index) => context.fillText(line, canvas.width / 2, startY + index * lineHeight));
        return new THREE.CanvasTexture(canvas);
    }

    function createRoundedImageTexture(texture) {
        const img = texture.image; const maxSize = 512;
        const w = (img.width > img.height) ? maxSize : (img.width / img.height) * maxSize;
        const h = (img.width > img.height) ? (img.height / img.width) * maxSize : maxSize;
        const canvas = document.createElement('canvas'); canvas.width = w; canvas.height = h;
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = 'high';
        
        const r = Math.min(w, h) * 0.1;
        ctx.clearRect(0, 0, w, h);
        ctx.beginPath(); ctx.moveTo(r, 0); ctx.lineTo(w - r, 0); ctx.quadraticCurveTo(w, 0, w, r);
        ctx.lineTo(w, h - r); ctx.quadraticCurveTo(w, h, w - r, h); ctx.lineTo(r, h);
        ctx.quadraticCurveTo(0, h, 0, h - r); ctx.lineTo(0, r); ctx.quadraticCurveTo(0, 0, r, 0);
        ctx.closePath(); ctx.clip();
        ctx.drawImage(img, 0, 0, w, h);

        const newTexture = new THREE.CanvasTexture(canvas);
        newTexture.colorSpace = THREE.SRGBColorSpace; newTexture.generateMipmaps = false;
        newTexture.minFilter = THREE.LinearFilter; newTexture.magFilter = THREE.LinearFilter;
        return newTexture;
    }

    function onWindowResize() {
        const width = window.innerWidth, height = window.innerHeight;
        renderer.setSize(width, height);
        composer.setSize(width, height);
        camera.aspect = width / height;
        camera.position.set(0, 35, width < 768 ? 150 : 120);
        camera.updateProjectionMatrix();
    }

    function onCanvasClick(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(loveImages);
        if (intersects.length > 0) {
            showLoveCard();
        }
    }

    function showLoveCard() {
        const overlay = document.getElementById('love-card-overlay');
        const card = document.getElementById('love-card');
        const text = document.getElementById('love-card-text');
        const cardConfig = CONFIG.loveCards;
        card.style.backgroundImage = `url('${cardConfig.images[currentCardIndex]}')`;
        text.textContent = cardConfig.phrases[currentCardIndex];
        overlay.style.display = 'flex';
        currentCardIndex = (currentCardIndex + 1) % cardConfig.images.length;
    }

    function hideLoveCard() {
        document.getElementById('love-card-overlay').style.display = 'none';
    }

    function animate() {
        requestAnimationFrame(animate);
        const elapsedTime = clock.getElapsedTime();
        galaxyGroup.rotation.y = elapsedTime * CONFIG.galaxy.rotationSpeed;
        if (sphereMaterial) sphereMaterial.uniforms.uTime.value = elapsedTime;
        
        loveTexts.forEach(t => t.lookAt(camera.position));
        loveImages.forEach(i => i.lookAt(camera.position));
        
        if (CONFIG.shootingStars.enabled && Math.random() < CONFIG.shootingStars.spawnProbability) {
            createShootingStar();
        }
        
        shootingStars.forEach((star, index) => {
            star.position.add(star.userData.velocity);
            star.userData.life++;
            if (star.userData.life > 300) {
                scene.remove(star);
                shootingStars.splice(index, 1);
            }
        });
        
        controls.update();
        composer.render();
    }
    
    init();

    document.getElementById('start-button-image').addEventListener('click', () => {
        document.getElementById('start-screen').style.display = 'none';
        document.getElementById('background-music').play().catch(e => console.error("Error al reproducir m√∫sica:", e));
    });

    document.getElementById('love-card-overlay').addEventListener('click', hideLoveCard);
    </script>
</body>
</html>